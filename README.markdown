# Module Documentation

## Module LCF

#### `Validation`

``` purescript
type Validation d e = List d -> Eff (err :: Exception | e) d
```

A `Validation d e` constructs a proof/derivation `d` from the proofs of its subgoals.

#### `ProofState`

``` purescript
type ProofState j d e = { validation :: Validation d e, subgoals :: List j }
```

A `ProofState j d e` is a list of subgoals (judgements `j`) and a validation.

#### `Tactic`

``` purescript
newtype Tactic j d e
  = Tactic (j -> Eff (err :: Exception | e) (ProofState j d e))
```

A `Tactic j d e` is a strategy for constructing a proof in `d` of a judgement in `j` by transforming the proof state.

#### `runTactic`

``` purescript
runTactic :: forall j d e. Tactic j d e -> j -> Eff (err :: Exception | e) (ProofState j d e)
```


#### `lazyThenLT`

``` purescript
lazyThenLT :: forall j d e. Tactic j d e -> Lazy (List (Tactic j d e)) -> Tactic j d e
```

`lazyThenLT t ts` applies the tactics `ts` pointwise to the subgoals generated by the tactic `t`.

#### `lazyThenT`

``` purescript
lazyThenT :: forall j d e. Tactic j d e -> Lazy (Tactic j d e) -> Tactic j d e
```

`lazyThenT t1 t2` applies the tactic `t2` to each of the subgoals generated by the tactic `t`.

#### `thenLT`

``` purescript
thenLT :: forall j d e. Tactic j d e -> List (Tactic j d e) -> Tactic j d e
```

`thenLT t ts` applies the tactics `ts` pointwise to the subgoals generated by the tactic `t`.

#### `thenT`

``` purescript
thenT :: forall j d e. Tactic j d e -> Tactic j d e -> Tactic j d e
```

`thenT t1 t2` applies the tactic `t2` to each of the subgoals generated by the tactic `t`.

#### `semigroupTactic`

``` purescript
instance semigroupTactic :: Semigroup (Tactic j d e)
```

Tactics form a semigroup via the `thenT` tactical.

#### `monoidTactic`

``` purescript
instance monoidTactic :: Monoid (Tactic j d e)
```

Tactics form a monoid via the `idT` tactic, which is the unit of `thenT`.

#### `lazyOrElseT`

``` purescript
lazyOrElseT :: forall j d e. Tactic j d e -> Lazy (Tactic j d e) -> Tactic j d e
```

`lazyOrElseT` t1 t2` first tries `t1`, and if it fails, then tries `t2`.

#### `orElseT`

``` purescript
orElseT :: forall j d e. Tactic j d e -> Tactic j d e -> Tactic j d e
```

`orElseT` t1 t2` first tries `t1`, and if it fails, then tries `t2`.

#### `tryT`

``` purescript
tryT :: forall j d e. Tactic j d e -> Tactic j d e
```

`tryT` either succeeds, or does nothing.

#### `repeatT`

``` purescript
repeatT :: forall j d e. Tactic j d e -> Tactic j d e
```

`repeatT` repeats a tactic for as long as it succeeds. `repeatT` never fails.

#### `AdditiveTactic`

``` purescript
newtype AdditiveTactic j d e
  = AdditiveTactic (Tactic j d e)
```

The tactics also give rise to another semigroup and monoid structure, given by disjunction and failure.

#### `getAdditiveTactic`

``` purescript
getAdditiveTactic :: forall j d e. AdditiveTactic j d e -> Tactic j d e
```


#### `semigroupAdditiveTactic`

``` purescript
instance semigroupAdditiveTactic :: Semigroup (AdditiveTactic j d e)
```

The semigroup operation is given by `orElseT`.

#### `monoidAdditiveTactic`

``` purescript
instance monoidAdditiveTactic :: Monoid (AdditiveTactic j d e)
```

The monoid arises from the `failT` tactic, which is the unit of `orElseT`.



