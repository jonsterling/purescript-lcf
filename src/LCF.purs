module LCF
( Validation()
, ProofState()
, Tactic(..)
, runTactic

, lazyThenLT
, lazyThenT
, thenLT
, thenT
) where

import Control.Monad.Eff
import Control.Monad.Eff.Exception
import Data.List
import Data.Monoid
import Data.Traversable
import Data.Tuple
import Data.Lazy

-- | A `Validation d e` constructs a proof/derivation `d` from the proofs of its subgoals.
type Validation d e = List d -> Eff (err :: Exception | e) d

-- | A `ProofState j d e` is a list of subgoals (judgements `j`) and a validation.
type ProofState j d e = { subgoals :: List j, validation :: Validation d e }

-- | A `Tactic j d e` is a strategy for constructing a proof in `d` of a judgement in `j` by transforming the proof state.
newtype Tactic j d e = Tactic (j -> Eff (err :: Exception | e) (ProofState j d e))

runTactic :: forall j d e. Tactic j d e -> j -> Eff (err :: Exception | e) (ProofState j d e)
runTactic (Tactic t) = t

splitAt :: forall a e. Number -> List a -> Eff (err :: Exception | e) (Tuple (List a) (List a))
splitAt n ls =
  if n < 0
    then throwException $ error "splitAt: negative index"
    else if n == 0
      then return $ Tuple Nil ls
      else return $ go n ls
  where
    go _ Nil = Tuple Nil Nil
    go 1 (Cons x xs) = Tuple (Cons x Nil) xs
    go m (Cons x xs) =
      case go (m - 1) xs of
        Tuple xs' xs'' -> Tuple (Cons x xs') xs''

mapShape :: forall a b e. List Number -> List (List a -> Eff (err :: Exception | e) b) -> List a -> Eff (err :: Exception | e) (List b)
mapShape Nil _ _ = return Nil
mapShape (Cons n ns) (Cons f fs) xs = do
  Tuple ys zs <- splitAt n xs
  Cons <$> f ys <*> mapShape ns fs zs

refine :: forall j d e. Validation d e -> List (List j) -> List (Validation d e) -> ProofState j d e
refine v subgoals vs =
  { subgoals : subgoals >>= id
  , validation : \ds -> mapShape (length <$> subgoals) vs ds >>= v
  }

-- | The identity tactic has no effect on the proof state.
idT :: forall j d e. Tactic j d e
idT = Tactic \j -> pure
  { subgoals: Cons j Nil
  , validation: \ds ->
      case ds of
        Cons d Nil -> return d
        _ -> throwException $ error "idTac: Wrong number of subderivations"
  }

unzipProofStates :: forall j d e. List (ProofState j d e) -> Tuple (List (List j)) (List (Validation  d e))
unzipProofStates = go $ Tuple Nil Nil
  where
    go r Nil = r
    go (Tuple jss vs) (Cons s ss) = go (Tuple (Cons s.subgoals jss) (Cons s.validation vs)) ss

-- | `lazyThenLT t ts` applies the tactics `ts` pointwise to the subgoals generated by the tactic `t`.
lazyThenLT :: forall j d e. Tactic j d e -> Lazy (List (Tactic j d e)) -> Tactic j d e
lazyThenLT t1 tsl = Tactic \j -> do
  state1 <- t1 `runTactic` j
  if null state1.subgoals then pure state1 else do
    states <- sequence $ (runTactic <$> force tsl) <*> state1.subgoals
    case unzipProofStates states of
       Tuple subgoals validations ->
         pure $ refine state1.validation subgoals validations

-- | `lazyThenT t1 t2` applies the tactic `t2` to each of the subgoals generated by the tactic `t`.
lazyThenT :: forall j d e. Tactic j d e -> Lazy (Tactic j d e) -> Tactic j d e
lazyThenT t1 t2l = Tactic \j -> do
  state1 <- t1 `runTactic` j
  if null state1.subgoals then pure state1 else do
    states <- traverse (runTactic $ force t2l) state1.subgoals
    case unzipProofStates states of
       Tuple subgoals validations ->
         pure $ refine state1.validation subgoals validations

-- | `thenLT t ts` applies the tactics `ts` pointwise to the subgoals generated by the tactic `t`.
thenLT :: forall j d e. Tactic j d e -> List (Tactic j d e) -> Tactic j d e
thenLT t1 ts = lazyThenLT t1 $ pure ts

-- | `thenT t1 t2` applies the tactic `t2` to each of the subgoals generated by the tactic `t`.
thenT :: forall j d e. Tactic j d e -> Tactic j d e -> Tactic j d e
thenT t1 t2 = lazyThenT t1 $ pure t2

-- | Tactics form a semigroup via the `thenT` tactical.
instance semigroupTactic :: Semigroup (Tactic j d e) where
  (<>) = thenT

-- | Tactics form a monoid via the `idT` tactic, which is the unit of `thenT`.
instance monoidTactic :: Monoid (Tactic j d e) where
  mempty = idT

